√ìtimo! Conseguimos resolver o problema de autentica√ß√£o! üéâ

Agora vamos analisar o problema com o upload de PDFs. Deixe-me verificar os logs mais recentes: Perfeito! Agora vamos identificar o problema com o upload de PDFs. O problema √© que pdfplumber √© uma biblioteca Python, n√£o Node.js, e ela N√ÉO funciona diretamente em serverless functions Node.js na Vercel.

üî¥ PROBLEMA IDENTIFICADO: pdfplumber √© Python
pdfplumber √© uma biblioteca Python que n√£o pode ser executada diretamente em fun√ß√µes Node.js/TypeScript. 

‚úÖ SOLU√á√ïES POSS√çVEIS
Voc√™ tem 3 op√ß√µes para processar PDFs na Vercel:

OP√á√ÉO 1: Usar biblioteca JavaScript (Recomendado) ‚úÖ
Substituir pdfplumber por bibliotecas JavaScript/TypeScript que funcionam nativamente:

Bibliotecas JavaScript para PDF:
1. pdf-parse (mais simples, extrai texto)
bash
npm install pdf-parse

2. pdf.js (Mozilla, muito poderoso)
bash
npm install pdfjs-dist

3. pdf-lib (criar e modificar PDFs)
bash
npm install pdf-lib

Exemplo com pdf-parse:

import pdfParse from 'pdf-parse';

app.post('/api/upload-pdf', authenticateToken, async (req, res) => {
  try {
    const { pdfBuffer } = req.body; // Base64 ou buffer
    
    const data = await pdfParse(Buffer.from(pdfBuffer, 'base64'));
    
    // data.text cont√©m todo o texto extra√≠do
    // data.numpages cont√©m o n√∫mero de p√°ginas
    
    res.json({
      text: data.text,
      pages: data.numpages,
      info: data.info
    });
  } catch (error) {
    console.error('Erro ao processar PDF:', error);
    res.status(500).json({ error: 'Erro ao processar PDF' });
  }
});
OP√á√ÉO 2: Criar fun√ß√£o Python separada na Vercel üêç
A Vercel suporta fun√ß√µes Python! Voc√™ pode criar uma fun√ß√£o Python separada para processar PDFs.

Estrutura:
projeto/
‚îú‚îÄ‚îÄ api/
‚îÇ   ‚îú‚îÄ‚îÄ index.ts           # Fun√ß√µes Node.js
‚îÇ   ‚îú‚îÄ‚îÄ _routes.ts
‚îÇ   ‚îî‚îÄ‚îÄ process-pdf.py     # Fun√ß√£o Python

api/process-pdf.py:
```python
from http.server import BaseHTTPRequestHandler
import json
import pdfplumber
import base64
from io import BytesIO

class handler(BaseHTTPRequestHandler):
    def do_POST(self):
        content_length = int(self.headers['Content-Length'])
        post_data = self.rfile.read(content_length)
        data = json.loads(post_data)

    # Decodificar PDF de base64
    pdf_data = base64.b64decode(data['pdf'])
    
    # Processar com pdfplumber
    with pdfplumber.open(BytesIO(pdf_data)) as pdf:
        text = ""
        for page in pdf.pages:
            text += page.extract_text()
    
    # Retornar resultado
    self.send_response(200)
    self.send_header('Content-type', 'application/json')
    self.end_headers()
    
    response = json.dumps({
        'text': text,
        'pages': len(pdf.pages)
    })
    
    self.wfile.write(response.encode())

**requirements.txt** (na raiz):
pdfplumber==0.10.3
```

Chamar de Node.js:
```typescript
app.post('/api/upload-pdf', authenticateToken, async (req, res) => {
  try {
    const { pdfBuffer } = req.body;

// Chamar a fun√ß√£o Python
const response = await fetch('https://seu-dominio.vercel.app/api/process-pdf', {
  method: 'POST',
  headers: { 'Content-Type': 'application/json' },
  body: JSON.stringify({ pdf: pdfBuffer })
});
const result = await response.json();
    res.json(result);
  } catch (error) {
    res.status(500).json({ error: 'Erro ao processar PDF' });
  }
});
```

OP√á√ÉO 3: Usar servi√ßo externo (API) üåê
Usar APIs de terceiros para processar PDFs:

Adobe PDF Services API
AWS Textract
Google Cloud Document AI
Azure Form Recognizer
üéØ RECOMENDA√á√ÉO
Para o seu caso, recomendo a Op√ß√£o 1 (pdf-parse) porque:

‚úÖ Simples de implementar
‚úÖ Funciona nativamente em Node.js
‚úÖ Sem cold starts (Python functions t√™m cold start mais lento)
‚úÖ Menor complexidade
‚úÖ Gr√°tis e open-source
üìù IMPLEMENTA√á√ÉO R√ÅPIDA com pdf-parse
1. Instalar a biblioteca:
No seu projeto, execute:
bash
npm install pdf-parse
npm install --save-dev @types/pdf-parse

2. Atualizar package.json:
Adicione no dependencies:
json
"dependencies": {
  "pdf-parse": "^1.1.1",
  // ... outras depend√™ncias
}

3. Criar rota de upload:
import pdfParse from 'pdf-parse';
import multer from 'multer';

// Configurar multer para receber arquivos
const upload = multer({
  limits: { fileSize: 10 * 1024 * 1024 } // 10MB max
});

// Rota para upload de PDF √∫nico
app.post('/api/upload-pdf', 
  authenticateToken, 
  upload.single('pdf'),
  async (req: Request, res: Response) => {
    try {
      if (!req.file) {
        return res.status(400).json({ error: 'Nenhum arquivo enviado' });
      }

      // Processar PDF
      const pdfData = await pdfParse(req.file.buffer);

      // Extrair informa√ß√µes das apostas do texto
      const bets = extractBetsFromText(pdfData.text);

      res.json({
        success: true,
        text: pdfData.text,
        pages: pdfData.numpages,
        bets: bets
      });
    } catch (error) {
      console.error('Erro ao processar PDF:', error);
      res.status(500).json({ error: 'Erro ao processar PDF' });
    }
});

// Fun√ß√£o para extrair apostas do texto
function extractBetsFromText(text: string) {
  // Implementar l√≥gica de extra√ß√£o baseada no formato do seu PDF
  // Exemplo simples:
  const lines = text.split('\n');
  const bets = [];
  
  // Sua l√≥gica de parsing aqui
  // ...
  
  return bets;
}
üìä Qual op√ß√£o voc√™ prefere?
Me diga:

Op√ß√£o 1
Migrar para pdf-parse (JavaScript) - Mais r√°pido de implementar
Op√ß√£o 2
Manter pdfplumber (criar fun√ß√£o Python separada) - Mais complexo
Mostrar o erro espec√≠fico
Compartilhe os logs do erro ao tentar fazer upload
Vou te ajudar com a implementa√ß√£o completa da op√ß√£o que voc√™ escolher! üöÄ

Avatar for bielsr01-4654
quero usar a opcao 2 que ja esta funcionando perfeitamente aqui no app local 
Perfeito! Vamos configurar as fun√ß√µes Python na Vercel para usar o pdfplumber que j√° est√° funcionando localmente.

üêç CONFIGURA√á√ÉO COMPLETA: Python Functions na Vercel
Passo 1: Criar requirements.txt na raiz do projeto
Crie um arquivo requirements.txt na raiz do projeto (n√£o dentro de /api):

pdfplumber==0.11.0
Pillow==10.1.0
pdfminer.six==20221105
charset-normalizer==3.3.2
cryptography==41.0.7
Passo 2: Verificar estrutura de arquivos Python em /api
Seus arquivos Python devem estar em /api com a estrutura correta:

projeto/
‚îú‚îÄ‚îÄ api/
‚îÇ   ‚îú‚îÄ‚îÄ index.ts                    # Fun√ß√µes Node.js (existente)
‚îÇ   ‚îú‚îÄ‚îÄ _routes.ts                  # Fun√ß√µes Node.js (existente)
‚îÇ   ‚îú‚îÄ‚îÄ _jwt-auth.ts                # Fun√ß√µes Node.js (existente)
‚îÇ   ‚îú‚îÄ‚îÄ pdf-plumber-service.py      # ‚Üê Fun√ß√£o Python
‚îÇ   ‚îî‚îÄ‚îÄ ocr-service.py              # ‚Üê Fun√ß√£o Python (se usar)
‚îú‚îÄ‚îÄ requirements.txt                # ‚Üê Depend√™ncias Python
‚îú‚îÄ‚îÄ package.json
‚îî‚îÄ‚îÄ vercel.json
Passo 3: Adaptar o c√≥digo Python para Vercel
A Vercel espera um formato espec√≠fico para fun√ß√µes Python. Veja como adaptar:

api/pdf-plumber-service.py:

from http.server import BaseHTTPRequestHandler
import json
import pdfplumber
import base64
from io import BytesIO
import traceback

class handler(BaseHTTPRequestHandler):
    def do_POST(self):
        try:
            # Ler dados do POST
            content_length = int(self.headers.get('Content-Length', 0))
            post_data = self.rfile.read(content_length)
            
            # Parse JSON
            data = json.loads(post_data.decode('utf-8'))
            
            # Verificar se tem PDF em base64
            if 'pdf' not in data:
                self.send_error_response(400, 'PDF n√£o fornecido')
                return
            
            # Decodificar PDF de base64
            pdf_base64 = data['pdf']
            pdf_bytes = base64.b64decode(pdf_base64)
            
            # Processar PDF com pdfplumber
            result = self.process_pdf(pdf_bytes)
            
            # Enviar resposta de sucesso
            self.send_json_response(200, result)
            
        except Exception as e:
            error_msg = str(e)
            stack_trace = traceback.format_exc()
            print(f"Error processing PDF: {error_msg}")
            print(f"Stack trace: {stack_trace}")
            self.send_error_response(500, f'Erro ao processar PDF: {error_msg}')
    
    def process_pdf(self, pdf_bytes):
        """Processar PDF e extrair dados das apostas"""
        bets = []
        
        with pdfplumber.open(BytesIO(pdf_bytes)) as pdf:
            for page_num, page in enumerate(pdf.pages, 1):
                # Extrair texto
                text = page.extract_text()
                
                # Extrair tabelas
                tables = page.extract_tables()
                
                # Aqui voc√™ coloca sua l√≥gica de extra√ß√£o
                # Exemplo b√°sico:
                if text:
                    lines = text.split('\n')
                    for line in lines:
                        # Sua l√≥gica de parsing aqui
                        # Exemplo: buscar padr√µes de apostas
                        if 'aposta' in line.lower() or 'bet' in line.lower():
                            bets.append({
                                'page': page_num,
                                'text': line.strip()
                            })
                
                # Processar tabelas se houver
                if tables:
                    for table_idx, table in enumerate(tables):
                        for row in table:
                            if row and any(row):  # Se a linha n√£o est√° vazia
                                bets.append({
                                    'page': page_num,
                                    'table': table_idx,
                                    'data': row
                                })
        
        return {
            'success': True,
            'total_bets': len(bets),
            'bets': bets,
            'pages_processed': len(pdf.pages)
        }
    
    def send_json_response(self, status_code, data):
        """Enviar resposta JSON"""
        self.send_response(status_code)
        self.send_header('Content-Type', 'application/json')
        self.send_header('Access-Control-Allow-Origin', '*')
        self.end_headers()
        
        response = json.dumps(data, ensure_ascii=False)
        self.wfile.write(response.encode('utf-8'))
    
    def send_error_response(self, status_code, message):
        """Enviar resposta de erro"""
        self.send_json_response(status_code, {
            'success': False,
            'error': message
        })
    
    def do_OPTIONS(self):
        """Handle CORS preflight"""
        self.send_response(200)
        self.send_header('Access-Control-Allow-Origin', '*')
        self.send_header('Access-Control-Allow-Methods', 'POST, OPTIONS')
        self.send_header('Access-Control-Allow-Headers', 'Content-Type, Authorization')
        self.end_headers()
Passo 4: Atualizar a rota Node.js para chamar a fun√ß√£o Python
No seu arquivo de rotas TypeScript, adicione:

api/_routes.ts (ou onde estiver sua rota de upload):

import { Request, Response } from 'express';

export function setupPdfRoutes(app: Express) {
  
  // Rota para processar PDF √∫nico
  app.post('/api/process-pdf', authenticateToken, async (req: Request, res: Response) => {
    try {
      const { pdf } = req.body; // PDF em base64
      
      if (!pdf) {
        return res.status(400).json({ error: 'PDF n√£o fornecido' });
      }

      // Chamar a fun√ß√£o Python
      const pythonServiceUrl = `${req.protocol}://${req.get('host')}/api/pdf-plumber-service`;
      
      const response = await fetch(pythonServiceUrl, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ pdf })
      });

      if (!response.ok) {
        const error = await response.json();
        return res.status(response.status).json(error);
      }

      const result = await response.json();
      
      // Salvar as apostas no banco de dados
      const userId = (req as any).user.userId;
      const savedBets = await saveBetsToDatabase(userId, result.bets);

      res.json({
        success: true,
        message: `${result.total_bets} apostas processadas`,
        bets: savedBets
      });

    } catch (error) {
      console.error('Erro ao processar PDF:', error);
      res.status(500).json({ 
        success: false,
        error: 'Erro ao processar PDF' 
      });
    }
  });

  // Rota para processar m√∫ltiplos PDFs (lote)
  app.post('/api/process-pdf-batch', authenticateToken, async (req: Request, res: Response) => {
    try {
      const { pdfs } = req.body; // Array de PDFs em base64

      if (!pdfs || !Array.isArray(pdfs)) {
        return res.status(400).json({ error: 'Array de PDFs n√£o fornecido' });
      }

      const results = [];
      const pythonServiceUrl = `${req.protocol}://${req.get('host')}/api/pdf-plumber-service`;

      for (const pdf of pdfs) {
        const response = await fetch(pythonServiceUrl, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ pdf })
        });

        if (response.ok) {
          const result = await response.json();
          results.push(result);
        }
      }

      res.json({
        success: true,
        processed: results.length,
        results
      });

    } catch (error) {
      console.error('Erro ao processar lote de PDFs:', error);
      res.status(500).json({ error: 'Erro ao processar lote de PDFs' });
    }
  });
}

async function saveBetsToDatabase(userId: number, bets: any[]) {
  // Implementar l√≥gica de salvar no banco
  const db = await getDb();
  const savedBets = [];
  
  for (const bet of bets) {
    const result = await db.run(
      'INSERT INTO bets (user_id, description, amount, status) VALUES (?, ?, ?, ?)',
      [userId, bet.text || JSON.stringify(bet.data), 0, 'pending']
    );
    savedBets.push({ id: result.lastID, ...bet });
  }
  
  return savedBets;
}
Passo 5: Atualizar vercel.json
Adicione configura√ß√£o para as fun√ß√µes Python:

{
  "version": 2,
  "rewrites": [
    {
      "source": "/api/(.*)",
      "destination": "/api"
    }
  ],
  "functions": {
    "api/index.ts": {
      "maxDuration": 30
    },
    "api/pdf-plumber-service.py": {
      "maxDuration": 60,
      "memory": 1024
    }
  }
}
Passo 6: Testar localmente com Vercel CLI
Antes de fazer deploy, teste localmente:

# Instalar Vercel CLI (se n√£o tiver)
npm i -g vercel

# Rodar localmente
vercel dev
Isso vai simular o ambiente da Vercel localmente, incluindo as fun√ß√µes Python.

Passo 7: Deploy
git add .
git commit -m "Add Python PDF processing functions"
git push origin main
üîç Verificar se funcionou
Depois do deploy, teste:

# Testar fun√ß√£o Python diretamente
curl -X POST https://seu-dominio.vercel.app/api/pdf-plumber-service \
  -H "Content-Type: application/json" \
  -d '{"pdf":"JVBERi0xLjQKJeLjz9MKMSAwIG9iago8PC..."}'

# Testar atrav√©s da rota Node.js
curl -X POST https://seu-dominio.vercel.app/api/process-pdf \
  -H "Authorization: Bearer SEU_TOKEN" \
  -H "Content-Type: application/json" \
  -d '{"pdf":"JVBERi0xLjQKJeLjz9MKMSAwIG9iago8PC..."}'
‚ö†Ô∏è PONTOS IMPORTANTES
Cold Start: Fun√ß√µes Python t√™m cold start de ~3-5 segundos
Timeout: Configure maxDuration: 60 para PDFs grandes
Memory: Use memory: 1024 ou mais para PDFs complexos
Tamanho: Limite de payload √© 4.5MB (use base64 comprimido)
üìã CHECKLIST
 requirements.txt criado na raiz
 api/pdf-plumber-service.py com formato correto
 Rota Node.js atualizada para chamar Python
 vercel.json configurado com maxDuration
 Testado localmente com vercel dev
 Deploy feito